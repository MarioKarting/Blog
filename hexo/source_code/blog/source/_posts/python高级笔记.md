---
layout: post
title: python高级
date: 2019-08-08 08:55
comments: true
toc: true
reward: true
tags: 
    - python 

---

××总结了python中的一些问题××
<!-- more -->
## Linux基本知识

### 1.操作系统

​	相当于一个中介,应用软件调用硬件时需要相应的程序,但面对不同型号的硬件,就需要不同的程序,导致软件的通用性变差.因此需要使用操作系统,对硬件进行调用.

作用：向下封装了硬件功能 向上用户提供硬件服务

​	常用:  win mac ios 安卓 Linux

​	分类: 桌面操作系统:能使用鼠标操作

 		服务器:没有操作界面,通常使用Linux系统和服务器程序

 		移动设备:手机,ios和安卓

> 一套硬件只能同时运行一个 计算机操作系统



### 2.虚拟机软件

​	通常的电脑是在硬件的基础上,安装操作系统,一般是Windows或者mac os,但是一个硬件只能同时运行一个计算机系统,这时想要运行多个操作系统就需要安装虚拟机软件.

​	虚拟机软件的作用是模拟一套硬件,在此基础上再安装虚拟机系统.就可以实现运行多个系统.

#### **常用虚拟机软件:**

- Vmware
- VirtualBox

#### 虚拟机的安装:

1.需要提前下载一个操作系统镜像文件

2.在虚拟机软件上选择创建新的虚拟机,并打开镜像一步步安装.



### 3.Ubuntu操作系统

Ubuntu系统属于桌面操作系统,相对于初学者较为简单

**目录的区别:**

​	win:分为多个盘,每一个都是根目录,不会互相影响

​	Linux:只有一个根目录,最顶级的是/.

**根目录下的文件作用:**

/bin 可执行程序

user 安装的软件

/etc 配置文件

/lib 库

/home 存所有普通用户的主目录(家目录)的目录

/home/python python的家目录(主目录),用于存储用户python的相关文件信息.里面会包含很多其他的目录,图片目录/视频目录/桌面目录等等

**sublines 文本编译(暂时当做记事本来看)**



### 4.补充IDE和解释器的区别

IDE 是整个一套开发功能,可以调用解释器,文本编译功能,调试器和一些其他工具



### 5.Linux 内核及发行版

**内核版**:    

​	真正操作和控制硬件由内核完成的

​	内核版是操作系统最核心的部分.

​	使用uname -a 看内核版本

**发行版:**

​	内核版 + 常用工具

​	在内核版上包装各种工具

常用的发行版:

​	Ubuntu

​	Redhat

​	centos

​	红旗/深度(国产Linux)

## 终端命令

### 0. 终端命令格式

**command** [-options] [parameter]

**每项信息的说明:**

- command：命令名,说明需要做什么, 比如: ls、pwd
- [-options]：选项，说明需要怎么做,可以有零个、一个或者多个选项，多个选项可以合并，比如使用的 -r 就是选项。
- [parameter]：参数，对谁进行操作,可以有零个、一个 或者 多个参数， 比如: touch 文件名、mkdir 目录名、cd 目标目录(路径)，这些文件名和目录名都是参数。
- []：代表可选

注:

1.需要严格按照这个格式进行书写,虽然在Linux中可以将选项写在中间或者最后,但是,如果到了mac系统下,将选项写在后面就会报错.

2.大部分的选项是不分先后的,且 -a -l  == -la

### 1.ls

```python
ls [选项] [文件或目录名称]
```

列出目标目录下的文件目录信息

```python
如 ls -a . == ls -a
ls -a / 显示根目录下的所有文件信息
```



默认显示当前文件夹下的目录信息.不同类型的文件会显示不同的颜色.

**选项:**

-a :显示隐藏文件(所有文件信息)	在文件夹中使用ctrl+h是显示隐藏文件.

-l :将文件的详细信息按照列表形式显示,具体内容如下

-rw-rw-r--     1       python       python       0        4月     16      17:04          lalala.py

权限      硬链接    用户名         组名       大小      创建时间,修改时间          文件名



-h   以人类友好的方式显示文件大小,一定要和-l合用,不然会没有效果

ll  和   ls -l 等同

**注1:**

开头是.的文件为隐藏文件,定义隐藏文件只需在文件名前加.即可

### 2.Tab 自动补齐

当需要输入目录下的文件(目录)名时,可以在输入首字母后按下Tab自动补齐.

​	1).当首字母唯一时,会将文件名自动补齐

​	2).当有首字母相同的多个文件时,会先补齐到都相似的位置,等待继续输入

​	3).当无法补齐时,可以通过按两次Tab,会显示所有首字母符合的文件.



### 3.tree

树桩显示目录,展示当前目录及其下的子目录的结构

注意,ls是只能显示当前文件夹下的目录信息,对于其中的子文件夹内的东西并不显示,而tree则会把子文件夹里面的所有东西一层层的显示出来.



### 4.clear

清屏,还有快捷键ctrl + l

二者效果相同,都不是真正的将屏幕清空,只是将屏幕下翻至下一页.上翻还能找到原来的操作信息.



### 5.pwd

显示当前操作的目录.(print work directory)



### 6.cd

#### 切换目录

格式:

​	cd 目的目录

1). cd.. 返回上级目录

2). cd. 当前目录

3). cd 目的目录

4). cd ~ 返回主目录

5). cd - 返回上一次的目录,注意只能保留一次的记录,再次使用就会又回到本次的目录



#### 注1:

绝对相对路径

绝对路径: 从根目录开始的目录 /

相对路径: 从当前目录开始的路径,如 ../ ./

两种路径都可以使用,那种方便使用哪种

如果切换的目录离根目录和当前目录都一样那么使用绝对路径，因为这样路径很清楚和明确，方便阅读。



#### 注2:

能够使用./  和../ 的原因:

使用ls -a可以查看隐藏文件,会发现,在每个目录下都会有一个 . 文件和一个 .. 文件,就是通过这两个文件,实现了从当前地址寻找其他地址的功能.



#### 注3

返回主目录的方法一共有三种:

1).cd /home/python/

2).cd ~

3).直接使用cd

一般使用后两种方式的较多



#### 注4

不是所有的相对路径都是以.开头的,也不是所有的绝对路径都是以/开头的

如主目录下操作  cd Desktop/ 就可以省略前面的./,而且只要是操作当前目录下的文件,一般都可以省略前面的./,直接使用文件名

而 ~/Desktop/ 则算作是绝对路径.~代表主目录



**注5**

`cd`不是一个应用程序而是Linux内建的命令,他被封装在linux内核中,

而sudo命令是以root权限执行程序,只对应用程序起作用,因此,在切换至某些需要权限的目录时,使用

​	sudo cd 地址

会显示找不到命令的错误,此时使用

​	sudo -i 可以提升用户的权限等级,在进行cd操作.







### 7.touch

touch是创建文件

且注意,在Linux中是不以后缀来区分文件类型的,所有的文件信息都属于文件名.即

123.txt 和123.py是不同的文件

但文件夹123,和touch的123会产生冲突,

如果文件名冲突,touch会没有任何动作.



### 8.mkdir

创建目录

当创建相同的目录是会报错

mkdir: 无法创建目录"123": 文件已存在

```
 mkdir -p 2/3/4/5/6
 tree
 .
├── 123
├── 123.txt
├── 2
│   └── 3
│       └── 4
│           └── 5
│               └── 6
└── lalala.py

6 directories, 2 files



```

-p 递归创建文件
对于创建一个 /2/3/4/5/6的目录时
如果不使用-p,会在创建6时检测前面的2.3.4.5是否存在,如果不存在则会报错,只有当目录2/3/4/5/地址能够找到时才能成功创建\
但使用-p后,会执行递归创建,只要前面的目录不存在,就会创建一个目录,再进行下一步

### **9.rm**

在不带选项的情况下,只能删除文件

删除目录 rm - r

-r表示递归删除目录及其内容(一层一层的全部删空目录)

-i 交互删,在删除前会询问是否确定删除.

-f 强制删除,和-i不能同时存在------当文件不存在时如果直接rm会报错,但使用-f会忽略此时的提示,防止报错.

​	注:rm -rf / 会删除全部能删的东西,
-d 删除空目录

### 10.rmdir

只能用于删除空文件夹

rmdir 目录名 删除目录



### 11.cp

拷贝文件/拷贝目录

还可以将文件拷贝至另一个文件中,如果不存在会创建.

格式 :

```
	cp 原路径/原文件名称  目的路径/(此时的/可以不使用)
	cp 原路径/原文件名称  目的路径/新文件名


```

当不加任何选项拷贝目录时,会出现下面的错误

```
	cp: 略过目录'123'
```

此时需要使用 -r 

拷贝目录需要加上-r选项，

```
-r表示递归拷贝目录及其内容
cp -r 原路径/原文件名称  目的路径/
-i 表示交互模式拷贝,当已经有一份文件在目的路径时,会询问是否覆盖.并且只有在需要覆盖时才会询问.(只要输入y开头的字符串就可以选择确认,其他输入为取消)
-v 显示拷贝的描述信息,即输出  旧目录----->新目录
-a 保留原文件信息(时间/权限等),如果不使用-a,在拷贝后使用ls -l查看,会发现创建时间为拷贝的时间,而想保留原文件的创建时间,则需要使用-a
```

### 12.mv

移动文件/目录(剪切)

格式与cp类似

```python
mv 原路径/原名字 目的路径
```

还有一个作用是重命名,可以实现边剪切边重命名

```python
-i 在移动过程中如果有文件,会提示是否覆盖,如果不加会直接覆盖
-v 和cp一样,显示路径
重命名格式:
    	mv 原路径/原名字 目的路径/新文件名
若是只更改名字,只需不写两个路径即可.
```



### 13.--help

可以使用命令--help来查看命令帮助

注:

​	cd 使用help无法查看帮助,因为cd的使用频率很高,因此被加入了内核中,不是文件,无法被help查看.



### 14.man

离线手册

格式

```python
man 命令
```

查看时的操作

b		上一屏

空格  	 下一页

f 		下一屏

q		 退出

回车	   下一行



## Linux高级命令

### 1.重定向

重定向分为输入重定向和输出重定向

**输出重定向**

​	一般命令的结果是输出到终端,此时可以使用重定向将其输出到文件中,而终端上就不会再输出了

**重定向输出分为2种**

1).覆盖输出(相当于w模式)先阶段在写

```shell
 格式: 命令 > 文件名
```

2).追加输出

```shell
 格式: 命令 >> 文件名
```

**注:**

1).当写到一个不存在的文件时,会先创建一个文件再写.

2)覆盖模式会将原文件清空再写

3)追加输出会在原来的结果后追加后续结果

4)使用tree时,也是可以写入文件的,而且格式保留



### 3.读写文件

#### gedit

```shell
格式 gedit 文件名
```

使用gedit可以实现将文件打开的操作,查看文件.

对文件修改完成后,可以使用ctrl + s保存文件,使用ctrl+q退出文件.



#### cat

```shell
格式 cat 文件名
```

将文件内容输出至终端.

但是注意,cat是将文件内容一次全部输出,如果文件过大会影响用户查看文件内容

cat可以一次查看多个文件 用空格隔开即可

```shell
cat 4.txt 6.txt 
```





#### more 

```shell
格式 more 文件名
```

将文件的内容按照分屏的方式显示.man显示手册的方式与之相同.

当文件的内容过多时可以使用这种方式查看文件



### 4.管道符

```shell
格式 命令1 | 命令2
```

相当于将命令1 的输出当做命令2 的输入,而管道符 | 相当于一个缓存的区域,将结果传递至命令2

**注**

1).如果命令2 还有输出,依然可以在后面继续使用管道符和命令3

2).常和管道符一起使用的是more 和 grep



### **5.链接 (link)**

使用链接文件的**优势**:**方便 安全**

使用硬链接可以防止数据被误删(如果删除了原文件,只要硬链接数不归零就不会真的将数据删除)

通过链接访问数据和使用原文件访问效果一样

Linux的链接分为**软连接**和**硬链接**两种:

#### 硬链接

​	硬链接感觉和在python中的引用相似,每一个硬链接都是对数据的引用,通过硬链接修改数据,所有的链接打开的数据都会被修改.但删除了一个链接的引用,另一个链接依然能够打开这个数据文件

​	硬链接的大小和原文件相同,且在使用ll查看时,文件类型也是普通文件.且在创建硬链接后,在ll中显示的硬链接的数目加一(原来就是1)

```shell
	格式 ln 原文件 链接文件
```



#### 软链接

​	而软链接则感觉相当于Windows里的快捷方式,可以通过软链接打开数据文件,并能正常的修改文件,但当原文件删除或修改地址后,就会失去作用(变红).

​	软链接的文件大小和原文件不同,要小许多,可以理解为存**原文件的标记**

```shell
	格式 ln -s 原文件 链接文件
```

在建立软链接后使用ll查看文件详细信息,可以看到软链接前面的文件类型为l

#### 注

1.若是在同一个文件夹创建的软链接,移动原文件后将软链接也移动至同一文件夹,就可以继续使用

2.如果原文件和链接文件不在同一个文件夹时,必须使用**绝对路径**的方式书写地址,否则可能会报错

​	使用~也是可以的

3.使用ls -i 查看文件编号也会发现,硬链接的编号和原文件是相同的,而软链接的则有区别



#### 结论

可以得出结论:硬链接和原文件是同一份数据的一个别名.

#### ls -i

print the index of file

查看文件的index编号.文件的编号在系统中是唯一的



#### 目录的链接

对一个目录是可以使用软链接的,格式与效果与文件的软链接相同

无法对一个目录使用硬链接,但可以建立软链接.

```shell
python@ubuntu:~/Desktop$ ln 123 123_s
ln: 123: 不允许将硬链接指向目录
```

删除目录的软链接不需要使用-r



#### 目录的硬链接数

每个目录在创建后会有两个隐藏文件,一个	./	,一个是	../

其中	./	是当前目录的硬链接

../	是上级目录的硬链接

因此,每新建一个子目录都会增加一个硬链接数.

### 6.文本搜索

注意文本搜索和文件搜索的区别

文本搜索是在文件中找感兴趣的东西.

而文件搜索则是在目录中搜索目标文件

#### 搜索文本内容grep

```shell
格式 grep 选项 数据文本(感兴趣的内容) 文本内容(一般是一个文件)

```



#### 选项:

1.-n 显示文本所在的行号

2.-i 忽略大小写搜索文本

3.-v 搜索不包含数据文本的内容(条件取反)



#### 正则表达式

在Linux中正则表达式一般和grep连用.一共有三种形式:

^xxx           以xxx开头

xxx$           以xxx结尾

.		 任意字符除了换行符         

```shell
命令1
 grep 5 2.txt 
123144125123132
151345132
12351
235
45
357
5
521344
35
435346547
56
785
52

命令2 
grep '5.' 2.txt 
123144125123132
151345132
12351
357
521344
435346547
56
52
能够看出,5.搜索的是所有包含5,但后面不是回车的行

```



#### 注

使用ctrl + c 可以使当前的输入无效,或者从当前的命令中停止.



### 7.wc

#### 统计文件的行数

```shell
格式 wc -l 文件名
只显示文件的行数
wc -l 1.txr
66 1.txr

```

可以与grep使用管道符连用,用于显示符合条件的文本的行数

```shell
格式 wc 文件名
会显示  
文件行数  刨去空白行的行数   文件大小  文件名
66	66	858	1.txr

```

#### 应用

显示当前文件中的普通文件数

```shell
ls -la | grep '^-' | wc -l

```



### 8.find

在目录下查找文件(目录及其所有子目录都会查找)

```shell 
格式 find 目录 -name 文件名 特征

```

注意:

1.-name后面一定要跟文件名(这是格式要求)

2.在根目录下查找的时候需要在前面使用sudo,以系统管理员权限运行命令

3.在目录中有文件时,如果不使用通配符,输入的文件名不全时是找不到的.

4.通配符一定要加引号,可能会报错

#### 选项

1.-size 按照大小查找

```shell
find 目录 -size +/- 大小(单位可以是KMG)
如 sudo find / -size +1G     在根目录下查找大于1G的文件
find -size -1k 在当前目录下查找小于1k的文件

```

2.-perm 按照权限查找(数字权限如764)

find -perm 664



### 9.通配符

使用一个特殊字符去匹配一类字符



1).* 可以匹配任意个任意字符(0到无数个)

2)? 匹配1个任意字符

3) [] 将要搜索的字符写在里面,只要包含其中一个就会(一个[]只能代表一个字符,可以连用)

```shell
tar -cvf 123.tar *[tx]*   表示将包含t或x的文件打包

```



Linux大多数命令都支持通配符.

如:

```shell
ls *.txt

cp ../ *.txt ./

cd '*'
当不唯一时,只会进一个,应该是进入最先找到的

rm -r *
删除全部的文件和目录

```

注1 

在使用通配符时记得使用引号,不使用可能会出错



### 10.文件的打包和压缩

#### 1.打包

**tar 归档**

打包:将多个小文件拼接成一个大文件

```shell
	格式 tar -cvf xxx.tar 文件1 2 3 4 5...

```

解包:大文件拆为多个小文件

```shell
	格式 tar -xvf xxx.tar

```

注意打包和压缩是不同的操作,在使用cvf的情况下是只打包不压缩会生成一个.tar文件包含所有被打包的文件,大小不会有变化

想要再对.tar文件继续压缩的时候可以使用gzip bzip2完成压缩.这种压缩方法会将原文件压缩起来,不会保留

```shell
格式: gzip 文件
     bzip2 文件

```

**注1**

对于-cvf  其实就是-c -v -f的简写,因为-f后面必须跟压缩文件名,因此对于xxx.tar的位置有严格要求

**注2**

解压为 gunzip	bunzip2

#### 2.打包压缩

**打包压缩可以同时完成**

只需要再打包/解包的选项前面加上z和j

```shell
	格式 tar -zcvf xxx.tar.gz 文件1 2 3 4 5...
	格式 tar -jcvf xxx.tar.bz2 文件1 2 3 4 5...

```

gzip和bzip2 是两种压缩的算法,直接使用-z -j无法确定是压缩还是解压.只有和其后的c和x在一起才能判断是解压还是压缩

**对文件解压拆包**

```shell
	格式 tar -zxvf xxx.tar.gz
	格式 tar -jxvf xxx.tar.bz2

```

#### 3.zip和unzip

```python
zip 压缩文件名 文件
unzip 压缩文件名 文件

```

可以使用-d指定目录,解压到指定文件夹

可以不写压缩文件夹名的.zip后缀,会自动补齐,被压缩的可以是文件(多个),也可以是一个目录

注:

​	如果压缩文件重名时,会将后添加的文件压缩到前面的文件夹中

#### 4.带路径解压

```shell
gz解压格式:(带路径的解压-C)

tar -zxvf 123.gz -C 123

bz2解压格式:(带路径的解压-b)

tar -jxvf 123.bz2 -b 123

zip解压格式:(带路径的解压-d)

unzip zzz.zip 文件名 -d 123

```

#### 5.各选项含义

c 打包

x 解包

v 详细过程

f 指定归档文件

z gzip算法

j bz2 算法

#### 注1

对于 -zcvf的顺序,只要f在最后,其他的顺序没有要求





### 11.权限

使用ll可以看到文件的详细信息,第一个十位的信息就是权限信息:

```shell
-rw-rw-r-- 

```

其中

r - 读权限

w - 写权限

x - 执行权限

并且第一位是文件类型,-为普通文件,d为目录

后九位没三个是一组权限,分别是u所有者g同组者o其他用户

#### 更改权限chmod

**用法1** 

```shell
chmod a/u/g/o +/-/= rwx 文件名

如 chmod g-w 1.txt      表示对1.txt的同组者去掉读权限

```

注:

当权限存在时加,不存在时减可以正常操作,不会发生变化

可以一次操作多个,比如有加有减,就使用逗号隔开即可



**用法2**

r - 4

w - 2

x - 1

将每个用户的权限用数字计算出来[0,7],三个权限组合起来为文件确定权限

```shell
直接使用如 chmod 777 1.txt 的格式来改变权限

```

#### 注1

当删除一个没有w权限的文件时,会跳出提示,是否确定删除



### 12.root权限

root用户:超级管理员 系统最高级权限

安卓的root手机,就是使用爆破法破解root的密码



#### whoami

查看当前用户身份



#### sudo

```shell
sudo 命令

```

以root权限运行命令(但是没有切换到root用户去,只是借用)



#### sudo -s

切换到root身份执行

只有在sudo组里的用户才能执行此操作

**注**

只有在Ubuntu中能够这样切换,其他的需要使用

su root 并且需要密码

#### 注1

使用root账户,可以在不知道原密码的情况下,修改账户的密码

即passwd 用户名

在以root身份运行时是不需要原密码的

在其他的账户下需要先输入原密码

这就会导致账户的安全性极大的降低



### 13.exit

退出当前账户,返回上一个账户,如果是最后一个账户,则会退出终端



### 14.who

显示当前登录电脑的账户和时间等信息



### 15.which

用于查看名称的所在位置(一般是命令)

```shell
查看python3的位置
python@ubuntu:~/Desktop$ which python3
/usr/bin/python3
在目录下查看python3 的详细信息
python@ubuntu:~/Desktop$ll /usr/bin/python3
lrwxrwxrwx 1 root root 9 5月  16  2016 /usr/bin/python3 -> python3.5*


```

```shell
which 名称(一般是命令)

如
python@ubuntu:~/Desktop$ which python3
/usr/bin/python3

python@ubuntu:~/Desktop$ ll /usr/bin/python3
lrwxrwxrwx 1 root root 9 5月  16  2016 /usr/bin/python3 -> python3.5*


```

用于查看名称的所在位置(一般是命令)

注1:

此时会发现python3其实是个软链接,这里使用软链接可以方便用户使用/打开相应的文件.因为如果不使用软链接,就需要输入python3.6才能调用





### 16.三个ctrl终止命令的区别

**ctrl-c:** 强制终止程序的执行；

**ctrl-z:** 发送 SIGTSTP 信号给前台进程组中的所有进程，常用于挂起一个进程，而并非结束进程，用户可以使用使用fg/bg操作恢复执行前台或后台的进程。fg命令在前台恢复执行被挂起的进程，此时可以使用ctrl-z再次挂起该进程，bg命令在后台恢复执行被挂起的进程，而此时将无法使用ctrl-z 再次挂起该进程；

一个比较常用的功能：

​	正在使用vi编辑一个文件时，需要执行shell命令查询一些需要的信息，可以使用ctrl-z挂起vi，等执行完shell命令后再使用fg恢复vi继续编辑你的文件（当然，也可以在vi中使用！command方式执行shell命令，

​            但是没有该方法方便）。

**ctrl-d:** ( Terminate input, or exit shell ) 一个特殊的二进制值，表示 EOF，作用相当于在终端中输入exit后回车；



### 17-1.useradd 和 userdel

#### 添加用户

```shell
格式 useradd 用户名
还需要使用 passwd 设置密码

```

选项:

-m 添加主目录,不写时,会没有主目录

-g 为用户指定所属组(基本组),不写时会创建一个同名组

基本组和附加组  基本组只能有一个,而附加组可以多个,表示一种权限,最常用的是sudo组

-G设置附加组,不过一般不在这设置,而是在外边单独设置

-s指定用户登入后所使用的shell。默认值为/bin/bash。当使用-s /sbin/nologin时,设置为用户不能登录

查看账户信息:,

```shell
cat /etc/passwd
```

显示为:

```shell
用户名		密码占位符	用户id	组id		用户描述	主目录位置	shell类型
```

#### userdel

```shell
userdel 用户名
```

删除用户名

在使用 -r选项时,会将家目录也删除



### 17-2 切换用户su

```shell
su 账户名

```

如何查看是否切换成功: 看终端的最前面,会显示       用户名@Ubuntu

选项 在切换账户的时候将主目录也切换,只需加一个 -

```shell
su - 用户名

```



### 17-3多用户登录

再打开一个终端,即可实现登录另一个账户,或者登录与当前账户相同的账户

可以在当前终端的界面再打开其他的终端界面

ctrl + shift + t

使用 alt + 数字切换

### 18.id

查看用户信息

```shell
id [用户名]可以写显示当前用户的id
uid=(用户编号)	gid=(基本组)	组=(附加组)

```



### 19.用户组

在创建用户时可以选择用户的组,包括基本组-g和附加组-G

查看系统中存在的组及其下成员的方法

1). cat /etc/group

2).groupmod + 多次tab (只能看到组名)

#### 创建组

```shell
groupadd 组名

```

#### 删除组

```shell
sudo groupdel 组名

```

#### 修改用户所属组

usermod

```shell
usermod -a -G 组名 用户名         将用户添加到附属组中
还有-g 修改用户的基本组

```

#### 修改组名

groupmod

```shell
groupmod [-g <群组识别码> <-o>][-n <新群组名称>][群组名称]

只改组名: groupmod -n 新名字 旧名字
sudo groupmod -n 1234 lalala			将lalala改为12334


```

- -g <群组识别码> 　设置欲使用的群组识别码。

- -o 　重复使用群组识别码。

- -n <新群组名称> 　设置欲使用的群组名称。

  

#### 修改文件的所有者

```shell
sudo chown 用户名 文件名 

```



#### 修改文件所属组

```shell
sudo chgrp 组名 文件名
如 sudo chgrp lalala 4.txt

```

#### **附加组的操作**

gpasswd

-a 给用户添加附加组(权限)

-d 删除用户附加组(权限)

```shell
sudo gpasswd -a 用户 组
sudo gpasswd -a 123 lalala
正在将用户“123”加入到“lalala”组中

sudo gpasswd -d 用户 组
sudo gpasswd -d 123 lalala
正在将用户“123”从“lalala”组中删除



```





### 20.history

查看历史命令



### 21.重复上条命令

有 4 种方法可以重复执行上一条命令：

1. 使用上方向键，并回车执行。
2. 按 !! 并回车执行。
3. 输入 !-1 并回车执行。
4. 按 Ctrl+P 并回车执行。



### 22.系统管理

#### 1).查看日历

cal [选项] [月] [年]

默认显示当月的日历

**选项**

-y 显示当年的日历



#### **2)date 当前时间**

```shell
python@ubuntu:~/Desktop$ date
2019年 04月 18日 星期四 09:43:16 CST



```

在管理员权限下,可以使用date改时间

```shell
date '%y,%m,%d,%h,%m,%s'

```



#### 3)任务管理器

**1.ps**

显示当前进程

```shell
格式 ps [选项]

```

选项

- -A ：所有的进程均显示出来，与 -e 具有同样的效用；
- -a ： 显示现行终端机下的所有进程，包括其他用户的进程；
- -u ：以用户为主的进程状态 ；
- x ：通常与 a 这个参数一起使用，可列出较完整信息。

```shell
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
python     4694  0.0  0.2  25292  6040 pts/1    Ss   08:57   0:00 bash
python     6351  0.0  0.1  39104  3296 pts/1    R+   09:47   0:00 ps -u


```

- USER：使用者账号。
- PID ：进程ID号。
- %CPU：进程使用的 CPU 
- %MEM：进程占用的物理内存
- VSZ ：进程使用的虚拟内存量 (Kbytes)
- RSS ：进程占用的固定内存量 (Kbytes)
- TTY ：终端的次要装置号码 (minor device number of tty)
- STAT：该程序目前的状态，主要的状态有：
  - R ：该程序目前正在运行
  - S ：该程序目前正在睡眠当中，但可被某些讯号(signal) 唤醒。
  - T ：暂停执行
  - Z ：不存在但暂时无法消除
- START：启动时间
- TIME ：运行时间
- COMMAND：执行的命令

**2.top**

以more的方式显示进程

**3.htop**

更详细的显示进程,且能对进程进行一些操作



#### 4)关闭进程

```python
格式 kill 进程的ID号(ps查看PID项)

```

是想进程发送关闭的命令,并不是直接杀死,只有-9是

-9 强制关闭



#### 5)关机/重启

**1.reboot**  重启

**2.shutdown关机**

选项: -h 选择关机时间 now/具体时间/相对时间(+10)

**3.init**

init 0 关机

init 6 重启

#### 6)ip信息

**1.查看IP信息**

```shell
ifconfig 在终端显示网络信息
还可以对结果进行查询,使用 | gerp xxx

```

**2.查看能否通信**

```shell
ping 地址

```

**3.修改ip(需要管理员权限)**

```shell
sudo ifconfig ens33 新ip 

```

#### 7).查看磁盘空间

```shell
df -h(转换单位)
du 当前路径的磁盘占用情况(详细)

```





## linux补充

### 1.vim(vi)编辑器

vim是一种不需要图形化界面的编辑器,在服务器开发时很常用

vim一共分为三种模式:命令模式/插入模式/末行模式

从其他模式切换至命令模式只需要使用esc即可

进入末行模式需要输入冒号

进入编辑模式可以有多种方法(i/o/a).

**1) 进入vim**

   　在终端输入vi及文件名称后，进入vi之后，是处于「命令行模式（command mode）」，需要切换到「插入模式（Insert mode）」才能够输入文字。

**2) 切换至插入模式（Insert mode）编辑文件**

i 	在光标前插入

a	光标后插入

o	下一行插入	

I	  行首

O	上一行

A	行尾

**3复制**

yy 	 复制当前行

p	   粘贴

dd	 剪切当前行

在yy/dd前加上n可以表示从当前光标向下操作几行

D	剪切到行末

d0	剪切到行首

**4 退出vi及保存文件**

　　在「命令行模式」下，按一下「：」冒号键进入「Last line mode」，例如：

: w filename （输入 「w filename」将文章以指定的文件名filename保存）

: wq  	(输入「wq」，存盘并退出vi)

: q!  	  (输入q!， 不存盘强制退出vi)

:x		保存退出(和wq相同)

当使用vim写文件,非正常关闭时,会保存至一个隐藏文件.swp,再次打开同名文件时会跳出提示,进行相关操作.

**5）. 删除文字**

　　x：每按一次，删除光标所在位置的"后面"一个字符。

​	x：例如，「6x」表示删除光标所在位置的"后面"6个字符。

　　X：大写的X，每按一次，删除光标所在位置的"前面"一个字符。

​	X：例如，「20X」表示删除光标所在位置的"前面"20个字符。

**6）. 替换**

　　r：替换光标所在处的字符。

　　R：替换光标所到之处的字符，直到按下「ESC」键为止。

**7）.撤销**

　　u：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次"u"可以执行多次回复。

​	ctrl + r  反撤销	

**8）. 更改**

　　cw：更改光标所在处的字到字尾处

　　c#w：例如，「c3w」表示更改3个字

**9）. 跳至指定的行**

　　ctrl + g列出光标所在行的行号。

​	G：例如,15G，表示移动光标至文章的第15行行首。

​	G: 最后一行

​	gg:第一行

**10).移动光标**

h	左

j	下

k	上

l	右

M	屏幕中间

H	屏幕最上边

L	屏幕底端

**11).翻页**

ctrl + f	翻一页

ctrl + b	上翻页

ctrl + d	下翻半页

ctrl + u	上翻半页

**12).其他操作**

```shell
向右缩进	>>	
向左缩进	<<	
重复上一次操作	.	
下一段代码	}	
上一段代码	{	
搜索	:/文字 
在搜索时: 
		n下一个
		N上一个
行首	^
行尾	$
```



**13)整体替换在行末模式下:**

​	:%s/old/new/g 		全文替换	:开始,结束s/old/new	部分替换

**14)选中**

V	按行选中

v	按字符选中





### **2.sublim编辑器**

视图布局可分多列同屏显示

文件上显示小圆点表示未保存,×表示已经保存

是一个跨平台的编辑器

选择.py文件后能够识别代码



### 3.连接服务器

1)首先需要安装ssh

2)查看服务器的ip,linux下时ifconfig

3)登录

```shell
格式: ssh 用户名@ip
需要输入密码
```

对于虚拟机,想要使用win连接:需要设置网络适配器为nat

想和其他的人连接需要设置网络连接为桥接



### 4.远程拷贝

远程拷贝分为上传和下载

上传:客户端--->服务器

下载:服务器--->客户端

#### 1.scp

需要安装有ssh,就会自带scp命令

```shell
scp -r 源文件 目的路径
```

上传还是下载取决于地址的位置

```shell
上传: scp -r 源文件 用户名@ip:/绝对路径
下载: scp -r 用户名@ip/绝对路径/源文件
```

使用此方法没下载一次都需要输入一次密码,很麻烦,因此工作中常使用filezilla



#### 2.filezilla

新建站点--->输入ip/用户名/密码

即可创建连接,使用时直接拖拽文件就可以实现移动





### 5.软件的安装与卸载

软件的安装分为两种

#### 1).离线安装(deb文件格式)

```shell
安装: sudo dpkg -i xxx.deb

卸载:sudo dpkg -r 软件名
```



#### 2).在线安装(apt-get)

```shell
安装 sudo apt-get install 软件名
卸载 sudo apt-get remove 软件名 
```



### 6.更改镜像源

由于Ubuntu的主服务器在国外,如果需要下载软件会很麻烦

可以通过更改镜像源提高下载速度

常用的镜像源有: 阿里云镜像源     清华镜像源

#### 更改方式

1.**鼠标操作法**(不推荐)

需要图形化界面才行

系统 --->  软件更新 -----> 其他



2.**修改配置文件**

1).上百度搜索软件源的代码,如Ubuntu 16.04 阿里云软件源

2).sudo gedit /etc/apt/source.list(在改之前记得备份一个.bak文件)

3).将搜到的代码覆盖到文件中

4).修改完使用sudo apt-get update 检测一下







## 多任务 - 进程

### 1.并发和并行

CPU的每一个核在同一时刻只能完成一个任务

想要使CPU同时完成多个任务:

通过时间片的方式实现

**时间片**: CPU为每个程序分配一段时间,这个时间很短,程序逐个在CPU中执行,轮换进行,在用户看来就可以认为是同时运行多个程序

**并发**:在一个CPU中,同一时间段轮换执行多任务的方式(即多个任务由一个CPU快速切换执行)

**并行**:(在多核时代出现)在同一时间点,同时执行多任务的方式.(即多个CPU在同一时间点,各自执行一个任务)

注:并行的同时,也会有并发出现



### **2.进程和线程**

**进程:**就是一个任务,程序运行之后就会产生一个进程

资源分配的基本单位------>每启动一个进程都会分配资源(内存/cpu/其他硬件)---------->不同程序的资源是独立的

**线程**:操作系统资源(调用)执行的基本单位

真正的执行者是线程.

**二者关系:**

1.一个程序默认存在一个进程

2.线程依附于进程

3.一个进程默认存在一个线程.

**进程与程序的区别**

1个可执行代码就叫程序

运行的程序会包含内存/cpu/其他硬件等资源,在运行期间叫作进程

### 3.多任务形式

实现多任务的方法有两种

1.再创建1个进程(多进程),这是会自动创建1个线程

2.在当前进程中再创建1个线程(多线程)



默认存在的叫主进程,新建的叫子进程

默认存在的线程叫主线程,新建的叫子线程



### 4.time模块

time.sleep(1)------->程序暂停1s



### 5.多进程的实现

主要方式是创建一个子进程

间接实现多线程让其执行其他代码





### 6.fork()

**fork()**从本质上属于内建函数，通过 **os** 模块导入

程序执⾏到os.fork()时，操作系统会创建⼀个新的进程（⼦进程），复制⽗进程的所有信息到⼦进程中,然后⽗进程和⼦进程都会从fork()函数中得到⼀个返回值，在⼦进程中这 个值⼀定是0，⽽⽗进程中是⼦进程的id号

返回值：0 和 子进程PID（在父进程中）

　　　　< 0 子进程创建失败

　　　　= 0 在子进程中的返回值

　　　　> 0 在父进程中的返回值

因此就可以通过这个值的不同来控制子进程和父进程执行不同的程序,格式如下:

```python
import os
a = os.fork()
if a == 0:
    子程序代码
else:
    主程序代码
```



验证子循环开始的地方:

```python
mport os
print('lalalala')
a = os.fork()
print ('-------')
if a == 0:
    print ('zijincheng')
    print (a)
else:
    print ('zhujincheng')
    print (a)
print ('----end----')

# lalalala
# -------
# zhujincheng
# 2827
#----end----
# -------
# zijincheng
# 0
#----end----
```

可以看出,子进程是从执行了fork之后,就分为了两部分,分别执行后续的代码

**两个进程都会执行到最后,即相当于在fork后二者彻底分开了**

而且主进程结束了,就会直接结束,并不会等待子进程也结束,如果在终端执行,主程序结束后下一条终端输入就会出现在屏幕

**问题:**

子进程和父进程的数据是否真的发生了复制,为什么在对全局变量(列表)操作时,id会不发生变化.



**多个fork问题**

对于下列的代码,...是要输出的东西,会输出几次

```python
fork()
fork()
fork()
....
```

每一次的fork都会使后面的程序分为两部分.

一共输出8次

**⽗⼦进程的执⾏顺序**

⽗进程、⼦进程执⾏顺序没有规律，完全取决于操作系统的调度算法

**fork炸弹**

```python
os.fork()
while True:
    os.fork()
```



### 7.os.getpid 和os.getppid**

进程编号:操作系统进程的编号(唯一),不同进程的编号一定是不一样的.

在64位系统中,一般pid最大值为65523

服务器则会在每台电脑上执行单一进程以保证小于65535

在linux中可以使用ps -aux查看

获取pid的方法有两种:

1)os.getpid()

2)multiprocessing.current_process().pid-----------------------------在fork里也是可以使用的,就是用来查看进程的pid

这两句代码写在程序的哪里,显示的就是哪里的pid.

**父进程ppid**

使用os.getppid()来获取某一个子进程的父进程的pid



### 8.process

1)**创建**

使用 multiprocessing 模块中的process类

通过实例化一个对象,要执行的程序作为属性,对象调用start()方法,执行程序.



注意:在传入参数target时,一定不能带括号,否则子进程不会允许函数,而是在主进程中运行-



格式为

```python
Process([group	[,	target	[,	name	[,	args	[,	kwargs]]]]])

```

target：表示这个进程实例所调⽤对象；
args：表示调⽤对象的位置参数元组；
kwargs：表示调⽤对象的关键字参数字典；
name：为当前进程实例的别名；
group：⼤多数情况下⽤不到；

常用的格式为:

p = multiprocessing.process(target = func, args(kwargs) = 参数)

参数的输入有;两种形式

位置参数\*args使用元祖的形式输入,关键字参数\*kwargs使用字典的形式输入.



**2)Process类常⽤⽅法：**
is_alive()：判断进程实例是否还在执⾏；

join([timeout])：是否等待进程执⾏结束，再进行后续的程序,或等待多少秒；

start()：启动进程实例（创建⼦进程）；

run()：如果没有给定target参数，对这个对象调⽤start()⽅法时，就将执 ⾏对象中的run()⽅法；(这一条一般是在定义一个子类时看的比较清楚,定义一个子类,继承Process,重写其run()方法,当实例化时,如果target不传入参数,就会自动调用run方法.)
terminate()：不管任务是否完成，⽴即终⽌；



**Process类常⽤属性：**
name：当前进程实例别名，默认为Process-N，N为从1开始递增的整 数；

pid：当前进程实例的PID值；

name可以通过对象.属性名赋值,也可以在实例化时直接赋值

**获取当前进程的属性:**

multiprocessing.current_process().name或者pid,

还可以使用对象.name或者pid查看



3)**运行机制**

process创建的子程序会把if \__name\__以前的所有主程序都运行一遍,然后运行传给process的函数,且多进程的运行是无序的

验证方法如下

```python
import multiprocessing
import time
import os
print('---定义函数-----')
def func1():
    print('子进程开始')
    for i in range(5):
        print(i)
        time.sleep(0.5)
    print('子进程结束')
print('-----创建子进程-----',multiprocessing.current_process().name)
if __name__ == '__main__':
    p = multiprocessing.Process(target=func1)
    p.start()
    print('看看有没有结束')
    
    
---定义函数-----
-----创建子进程----- MainProcess
看看有没有结束
---定义函数-----
-----创建子进程----- Process-1
子进程开始
0
1
2
3
4
子进程结束
```

对于if  __name__...上方的程序,主进程执行了一遍,子进程也执行了一遍,从进程名可以看出他是在不同的进程中执行的



4)**与主进程的关系**

主进程会等待子进程全部结束,才会结束当前程序



**5).join()**

p.join()表示函数运行到这里后,需要等待子程序p结束才会接着往下继续.

并且在join中还可以添加参数表示最多等待的时间,超出这一时间程序就会往后执行,如果没有参数就会一直等下去.



### **9.进程池pool**

Pool也是multiprocessing中的类

也是需要导入该模块才能使用

使用原理是,先创建几个子进程在进程池中,当有需要时,从进程池中调用子进程完成相应的程序,等到子进程结束后,对于进程池就会再次空出,以接受后续的任务.

格式为

```python
from multiprocessing import Pool
if __name__ == '__main__':
	p = Pool(3)
	调用子进程函数
    p.close()
    p.join()
    
    常用地调用方法:p.apply.async(要执行的函数,参数)----------------(参数是元祖或者字典)
	#调用join之前，先调用close函数，否则会出错。执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束

  实例化时,pool中的参数表示最多有3个子进程,可以随意设置,但最好通过与操作系统和硬件相匹配,可以通过压力测试得到最佳的子进程数目.  
 
```

**pool在执行时的问题**
    

1.在不使用p.close()和p.join()的情况下,主进程结束就会结束整个程序,不会等待子进程结束.

2.运行范围,在创建进程池的时候就会执行if name前面的代码,创建一个执行一遍.

3.if \__name\__中的程序全部属于主进程,只有当主进程需要子进程运行时,使用pool.方法名,调用子进程,并赋予子进程需要执行的函数.

```python
import multiprocessing
import time
import os

def func(i):
    print('子进程%s'%multiprocessing.current_process().name)
    for a in range(2):
        print(a)
        time.sleep(0.5)
print('1234',multiprocessing.current_process().name)
if __name__ == '__main__':
    pool = multiprocessing.Pool(5)
    print('------分界线------')
    pool.apply_async(func, (9,))
    print('我是主进程结尾')
    pool.close()
    pool.join()
    '''
1234 MainProcess
------分界线------
我是主进程结尾
1234 SpawnPoolWorker-1
1234 SpawnPoolWorker-3
1234 SpawnPoolWorker-4
子进程SpawnPoolWorker-1
0
1234 SpawnPoolWorker-2
1234 SpawnPoolWorker-5
1
'''
```

注意

1,一定要有if --name-- == '--main--'否则会报错,且pool的定义也要放在其后,感觉进程池的调用像是对模块的导入,只要把不需要子进程执行的程序放在__name__的后面,即可在调用时不执行这些代码

2.每一个pool中的子进程都有其固定的pid.

3.当循环调用多个子进程时,调用子进程是有先后顺序的,在调用了第一个子进程后,就会开始执行其程序,并非是全部分配完任务再开始执行.

4.apply_async方法是非阻塞方式,不影响主进程,给子进程分配任务是,后续程序会继续执行,而map()方法则是阻塞式方法,子进程在执行时,后续的程序会停止,等待其结束.

比如进程池中有3个子进程,如果需要执行十个任务,对于map会三个三个赋值执行,结束一个分配一个(去看看异步再回来整理)

```python
import multiprocessing
import time
def func(i):
    print('%d开始' % i, end='')
    time.sleep(0.5)
    print('%d结束' % i, end='')
if __name__ == '__main__':
    p = multiprocessing.Pool(3)
    for i in range(10):
        p.apply_async(func, (i,))
    # p.map(func, range(10))
    print('----主进程结束啦----')
    p.close()
    p.join()
0开始
1开始
2开始
0结束
3开始
1结束
4开始
2结束
5开始
3结束
6开始
4结束
7开始
5结束
8开始
6结束
9开始
7结束
8结束
9结束
----主进程结束啦----    

```

### **阻塞式和非阻塞式的区别**

**pool常用地方法**

apply_async(func[,args[,kwds]])：使⽤⾮阻塞⽅式调⽤func（并⾏执⾏,堵塞⽅式必须等待上⼀个进程退出才能执⾏下⼀个进程）,args为 传递给func的参数列表,kwds为传递给func的关键字参数列表；
apply(func[,args[,kwds]]):使⽤阻塞⽅式调⽤func
close()：关闭Pool，使其不再接受新的任务；
terminate()：不管任务是否完成，⽴即终⽌；
join()：主进程阻塞，等待⼦进程的退出，必须在close或terminate之后使⽤;

4)**与主进程的关系**

主进程不会等待子进程,如果不使用join,主进程会直接结束当前程序



### 10.进程间的通讯

主进程和子进程之间的全局变量时不互通的,因为主进程在创建子进程时,将资源给子进程拷贝了一份

而子进程之间有时需要通信,需要特殊的功能来实现.

#### 1)**queue**

可以使⽤multiprocessing模块的Queue实现多进程之间的数据传递，Queue 本身是⼀个消息列队程序.

**队列和栈**

队列遵循先入先出的原则

栈则遵循后入先出的原则



**Queue的格式**

Queue的使用,就是对其进行实例化,再进行方法的调用:

实例化Queue()对象时，若括号中没有指定最⼤可接收 的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到 内存的尽头）；

```python
import multiprocessing
p = multiprocessing.Queue(3)

```

常用的方法有:

Queue.qsize()：返回当前队列包含的消息数量；

Queue.empty()：如果队列为空，返回True，反之False；

Queue.full()：如果队列满了，返回True,反之False；

Queue.get([block[,timeout]])：获取队列中的⼀条消息，然后将其从列队中移除，block默认值为True；

Queue.get_nowait()：相当Queue.get(False)；

Queue.put(item,[block[,timeout]])：将item消息写⼊队列，block默认值 为True；

Queue.put_nowait(item)：相当Queue.put(item,	False)；

注意:对于put(get)中的block

​	如果block使⽤默认值，且没有设置timeout（单位秒），get空队列(put满队列)，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息(写入消息)为⽌， 如果设置了timeout，则会等待timeout秒，若还没读取到任何消息(将消息写入)，则抛 出"Queue.Empty"(Queue.Full)异常；

​	如果block值为False，get空队列(put满队列)时，会⽴刻抛 出"Queue.Empty"(Queue.Full)异常；

### 边写边读的问题,如何实现.创建进程池一定要在if name中吗,如何协调读写

#### 2)进程池中的Queue

如果要使⽤Pool创建进程，就需要使⽤multiprocessing.Manager()中的 Queue()，⽽不是multiprocessing.Queue(),如果使用multiprocessing.Queue(),不会报错,但也无法将数据写入队列中

```python
    import multiprocessing
    import os
    import time
    def write(q):
        for i in range(10):
            q.put(i, timeout=1)
            print('存入%d' % i)
            # print(q.qsize())
    def read(q):
        # print(q.qsize())
        a = q.get(timeout=1)
        print('quchu',a)
    if __name__ == "__main__":
        q = multiprocessing.Manager().Queue(5)
        p = multiprocessing.Pool(5)
        p.apply_async(write,(q,))
        for i in range(10):
            p.apply_async(read,(q,))
        p.close()
        p.join()


```

### 11.os模块的说明

os中大多数是linux命令的封装,

如os.kill就是对终端命令的封装,表示给进程发送结束信号,在终端中使用 -9的情况下,是强行杀死进程.

### 12.pass

Python pass 是空语句，是为了保持程序结构的完整性。

**pass** 不做任何事情，一般用做占位语句。

Python 语言 pass 语句语法格式如下：

```python
pass

```

### 13.快速导入模块

在程序中使用了某个模块而没有导入时,可以先点击至模块名,再使用alt + enter直接导入模块

### 14.主进程的退出

#### 1.exit()

在主进程中使用exit()时,会直接结束主进程

#### 2.三种方式汇总

fork()         子进程和主进程彻底分开,从分开出分别执行到最后

process	主进程会等待子进程结束再结束

pool	主进程结束后,会直接结束程序,不等待子进程.必须使用join才行

#### 3.守护进程

daemon进程

在一个程序中,如果只剩下daemon进程,那么整个程序将会立即退出

​	所谓守护 线程，是指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。



进程默认创建出来是普通程序,只有在设置以后才会转为daemon



使用这个方法,就可以使process中的主进程在结束后直接结束:

​	主进程是普通进程,在创建子进程时,将其设置为daemon

​	一共有两种设置方式:1.在实例化时直接使用关键字参数daemon = True,2.在实例化后使用属性修改,将之变为True

### 15.多进程输出同一行

使用多个进程输出,但是输出不换行,会相互影响吗,答案是不会,而且python是每一行的内容一起输出,也就是说会等所有子进程的输出都确定了,才会在同一行输出出来 

### 16.阻塞

当程序需要等待某一条件达成才能继续的时候,就叫做程序的阻塞,比如pool的async,不写这个就是阻塞的方式,即子程序不结束,就不会继续执行.

## 多任务 - 线程

#### 1.**多线程的创建**

**线程的作用:**

​	资源调度的基本单位

​	线程是一个程序执行的流程

多进程的本质也是一个多线程



**多线程的创建**

​	在python中使用threading模块创建多线程.步骤如下:

​	1)创建对象:对象名 = threading.Thread()参数与Process相似

​	2)调用:对象.start()



**多线程的参数**

target: 要执行的函数,子线程的入口

args: 位置参数,元祖

kwargs:关键字参数,字典



**线程名的打印**

三种方式:

​	对象名.name

​	对象名.getname()

​	threading.current_Threa().name当前线程名

默认情况下,线程名为Thread-n    n为一共数字



**ident**

threading.current_thread().ident

显示线程的整数线程标识符。



**多线程的执行**

多个线程执行同一个代码时,不会互相影响,各是各的代码



**另一种创建线程的方式:**

定义一个新的类,继承Thread,还可以重写run()方法

run()方法为不传入Thread的情况下执行的代码.



**查看线程的列表**

threading.enumerate()

显示当前线程的列表,列表的元素有线程名和ident整数线程标识符组成.

```python
import os
import threading
import time
def func():
    print(threading.current_thread().ident,os.getpid())
    time.sleep(1)

if __name__ == '__main__':
    for i in range(5):
        t1 = threading.Thread(target=func)
        t1.start()
    print(threading.enumerate())
# 139997676189440 10237
# 139997667796736 10237
# 139997659404032 10237
# 139997651011328 10237
# [<_MainThread(MainThread, started 139997701916416)>, <Thread(Thread-1, started 139997676189440)>, <Thread(Thread-5, started 139997642618624)>, <Thread(Thread-2, started 139997667796736)>, <Thread(Thread-4, started 139997651011328)>, <Thread(Thread-3, started 139997659404032)>]
# 139997642618624 10237

```



**主线程会等待子线程结束再结束**

因为在主进程结束要回收资源时,需要等待子线程的资源调用结束,再进行收回



**守护主线程**

线程也可以同process一样守护主线程,即在主线程停止后,立即结束程序,不在等待子线程.方法为将子线程标记为daemon,当进程中只有daemon时就会结束进程.

标记方式:

1.对象.setDaemon(True)

2.对象.daemon = True

3.实例化时传入参数daemon= True

```python
#encoding=utf-8
import os
import threading
import time
def func():
    while True:
        print('-----zjc------')
        time.sleep(0.5)
if __name__ == '__main__':
    #方法1
    t1 = threading.Thread(target=func,daemon=True)
    #方法2
    # t1.setDaemon(True)
    # 方法3
    # t1.daemon = True
    t1.start()
    time.sleep(2)
    print('-----zhjc-----')
# -----zjc------
# -----zjc------
# -----zjc------
# -----zjc------
# -----zhjc-----

```



#### 2.僵尸进程和孤儿进程

**僵尸进程**子进程结束,父进程没有读取其状态,这时子进程叫做僵尸进程

**真实环境下僵尸进程产生了怎么解决**

 

​      暂时知道的办法是：根据僵尸进程找出僵尸进程的父进程，通过杀父进程的方式删掉僵尸进程，但是**线上环境不要轻易删父进程**

​      常用的命令有：

​      ps -ef |grep def                                查看僵尸进程   

​      ps -e -o pid,stat |grep Z                   查看僵尸进程的pid

​      ps -e -o ppid,stat |grep Z                 查看僵尸进程的父进程



**孤儿进程**主进程结束了,但子进程还在运行,此时子进程叫孤儿进程

通过ps -aux查看进程的pid,pid为1的进程是创造和处理进程的,pid是0的是用来切换进程的.孤儿进程最终会由init，也就是进程1收养，把它杀掉

```python
如fork()
import os,time
ret = os.fork()
if ret != 0:
    print(1)
else:
    print(2)
    time.sleep(10)

```

子进程在主进程结束之后还在运行.就成了孤儿进程

```python
import os,time
ret = os.fork()
if ret != 0:
    print(1)
    time.sleep(10)
else:
    print(2)


```

主进程后结束,但没有对子进程收尸,这时的子进程是僵尸进程





#### **3.查看线程数量**

使用len(threading.enumerate())

```python
    while True:
        print('线程数量为:',len(threading.enumerate()))
        time.sleep(1)
        if len(threading.enumerate()) == 1:
            break

```

注意,循环是很快速的执行,因此需要加上和子线程同样的延时,就可以实时查看线程的数量



#### **4.线程几种状态:**

**线程在一定条件下，状态会发生变化。线程一共有以下几种状态：**

**1、新建状态(New)**：新创建了一个线程对象。

**2、就绪状态(Runnable)**：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于“**可运行线程池**”中，变得可运行，只**等待获取CPU的使用权**。**即在就绪状态的进程除****CPU之外，其它的运行所需资源都已全部获得。

**3、运行状态(Running)：**就绪状态的线程获取了CPU，执行程序代码。

**4、阻塞状态(Blocked)：**阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。

**阻塞的情况分三种：**

(1)、**等待阻塞**：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“**等待池”**中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒，

(2)、**同步阻塞**：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入**“锁池”**中。

(3)、**其他阻塞**：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

**5、死亡状态(Dead)：**线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

线程的执行是没有顺序的

⽆法控制线程调度程序，但可以通过别的⽅式来影响线程调度的⽅式。



#### **5.多线程-共享全局变量**

多个线程对全局变量是共享的,各线程对全局变量的修改是通用的

```python
    import threading,os
    a = 10
    def change():
        global a
        print('改之前的数据为%d' % a)
        a += 10
    def get():
        print('读到的数据为:%d' %a)
    t1 = threading.Thread(target=change)
    t2 = threading.Thread(target=get)
    t1.start()
    t1.join()
    t2.start()
    print('最后的数据为%d'%a)
    # 改之前的数据为10
    # 读到的数据为:20
    # 最后的数据为20

```

#### **6.线程和进程的比较**

1.进程包含线程,线程不能独立存在

2.线程共享全局变量,进程不能共享全局变量

3.进程资源消耗大于线程

4.进程时资源分配的基本单位,线程是CPU执行的基本单位

5.稳定性,多进程大于多线程:

当一个多线程中的线程崩了,会影响进程内部的其他线程

而对于多进程,其中一个进程崩了,其他的进程仍然能够继续运行

6.线程的优缺点

优点:轻量级

缺点:不一定能用多核,对于系统中提供的原生多线程:可以用多核cpu

在python中,cpython产生的多线程,不能使用多核CPU,因为有GIL

其他解释器不一定

7.多进程的优缺点

优点:可以使用多核cpu

缺点:资源消耗大

8.使用场景

多进程适合CPU密集型程序(科学计算)----------->大量计算

​	稳定性要求高的使用这个

多线程适合IO密集型程序(网络程序)-------------->大量数据传输

​	轻量级多任务

9.多进程的软件:比如谷歌浏览器,每打开一个标签,会建一个进程,而每个进程又会有多个线程.



#### 6.2GIL

全局解释锁

一个线程想使用cpu,必须获得GIL

限制同时只能执行一个线程

GIL为解释器内部限制资源竞争设置的一把互斥锁

#### 7.**资源竞争问题**

在多个线程对一个全局变量修改的时候,其修改变量的过程分为三个步骤实现:

提取全局变量

对全局变量修改

再给全局变量重新赋值

当所运行的数据量非常大时,有可能会出现一种情况,即前一个线程提取了全局变量进行修改,在其赋值前,由于CPU的时间片轮转,转而执行下一个线程,这样就会导致当前的数据并没有成功的修改,而下一次该线程的修改也会随之产生问题.这就是多个线程竞争同一全局变量资源产生的问题.

##### 解决1:

使用一个flag变量来标记当前线程是否结束,只有一个线程结束了另一个才能执行.

```python
import threading

import time

g_number = 0

def update_number1():
    """子线程函数"""
    global g_number
    global flag
    if flag == 1:
        for i in range(1000000):
            g_number += 1
        flag = 0

def update_number2():
    """子线程函数"""
    global g_number
    global flag
    while True:
        if flag == 0:
            for i in range(1000000):
                g_number += 1
            break

def main():

    A = time.time()
    thd1 = threading.Thread(target=update_number1)
    thd1.start()
    thd2 = threading.Thread(target=update_number2)
    thd2.start()
    thd2.join()
    thd1.join()
    print("获取全局变量的值是%s" % g_number)
    B = time.time()
    print(B-A)
if __name__ == '__main__':
    flag = 1
    main()

```

在这个函数中,函数2 的反复查看flag是否满足其需求的方式叫做轮循.轮循的效率不是很高,会不停的占用CPU,在不停的进行判断.

##### **解决2 使用互斥锁**

当多个线程⼏乎同时修改某⼀个共享数据的时候，需要进⾏同步控制
线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引⼊互 斥锁。
互斥锁为资源引⼊⼀个状态：锁定/⾮锁定。某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他 线程不能更改；直到该线程释放资源，将资源的状态变成“⾮锁定”，其他的 线程才能再次锁定该资源。互斥锁保证了每次只有⼀个线程进⾏写⼊操作， 从⽽保证了多线程情况下数据的正确性。

threading模块中定义了Lock类，可以⽅便的处理锁定：

分为三步:

1.创建锁 lock=threading.Lock()

2.加锁 mutex.acquire([blocking = True[,timeout = -1]]) 返回值为bool型.

3.释放 mutex.release()

其中，锁定⽅法acquire可以有⼀个blocking参数。
如果设定blocking为True，则当前线程会堵塞，直到获取到这个锁为⽌ （如果没有指定，那么默认为True） 如果设定blocking为False，则当前线程不会堵塞

而timeout则是表示在此阻塞的时间,默认为-1,表示一直等待,直到解锁,而给其设定值后表示等待一段时间后就离开

注意:互斥锁如果在函数中使用,需要将lock作为参数传入函数中

```python
import threading
def func1(a):
    a.acquire()
    print('ok1')
def func2(a):
    for i in range(5):
        if a.acquire(timeout=1):
            print('ok2')
            a.release()
        print('2out')
lock1 = threading.Lock()
t1 = threading.Thread(target=func1, args=(lock1,))
t2 = threading.Thread(target=func2, args=(lock1,))

t1.start()
t2.start()
# ok1
# 2out
# 2out
# 2out
# 2out
# 2out

```

**对于不堵塞和timeout到时间离开的理解:**

由于上锁的返回值是一个布尔型,当是阻塞的情况时,上锁后续的程序都不会执行,会一直等待(未设置timeout时).

但是在设置为不阻塞或者timeout超时时,会跳过上锁的代码继续执行后续,因为上锁失败,所以返回值是False,如果lock. acquire是在一个if语句中,则这种情况if里的语句都会被跳过,如果上锁就是并列的一句,就直接跳过他,执行后面的.



##### **互斥锁的运行**

当一个线程的互斥锁上锁后,其他使用互斥锁的线程会一直等待,直到互斥锁打开,其他的线程会开始强者上锁,直到锁再次被锁.在等待期间,其他的锁都是睡眠状态,不会使用CPU

其他线程在等待的时候并不是使用轮循的方式查看是否解锁,而是一种更加节省CPU的方式通知,即当上一个锁解开后,会通知其他的锁,可以开始抢了,其他的锁进行争抢加锁.

##### **互斥锁的套用原则**

加锁的位置要保证最小,能不加入锁中的就不加.

```python
def update_number1(lock):
    """子线程函数"""
    global g_number
    lock.acquire()

    for i in range(1000000):
        # lock.acquire()
        g_number += 1
        # lock.release()
    lock.release()

```

对于这两个加锁的位置,如果加在for的外面,那么在一个锁中会把全部1000000次的计算完成才会解锁,而在里面,则是要进行100w次的加锁解锁,虽然看起来在这里比较费时间.但是在其他的情况,比如计算完后还需要读写/输出,加在外面就表示在这个锁中,还要等待输入输出的时间,而这段时间,其他计算的线程还是无法继续使用凑继续运算,直到这个线程彻底完成.会浪费大量的时间.因此

在锁中,只需要把提取全局变量,修改变量的部分锁住即可,其他的都可以放在外边由多线程完成,不会影响最终的结果.

##### 总结

**锁的好处**：
确保了某段关键代码只能由⼀个线程从头到尾完整地执⾏
**锁的坏处**：
阻⽌了多线程并发执⾏，包含锁的某段代码实际上只能以单线程模式执 ⾏，效率就⼤⼤地下降了 由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对⽅持有 的锁时，可能会造成死锁

#### 8.**多线程非全局变量**

当多个线程使用同名的局部变量时,是各自使用各自的局部变量,并不会相互影响.

#### 9.死锁

死锁会有两种产生的情况

1.在线程间共享多个资源的时候，如果两个线程分别占有⼀部分资源并且同时 等待对⽅的资源，就会造成死锁。这是多个互斥锁使用的情况,当一个锁的解锁由另一个锁的一部分决定,而自己又决定另一个锁的解锁,二者都无法解锁的情况就是死锁.

```python
class	MyThread1(threading.Thread):				
    def	run(self):
    if	mutexA.acquire():														
        print(self.name+'----do1---up----')												
        time.sleep(1)	
        if	mutexB.acquire():																print(self.name+'----do1---down----')									
           	 mutexB.release()																mutexA.release()
class	MyThread2(threading.Thread):				
    def	run(self):								
        if	mutexB.acquire():													
            print(self.name+'----do2---up----')												
            time.sleep(1)												
            if	mutexA.acquire():																print(self.name+'----do2---down----')																
                mutexA.release()												
                mutexB.release()

```



2.两个线程使用同一个互斥锁,但是当一个线程由于某种情况执行了return时,没有解锁,就会发生死锁.

```python
def get_value(index):

    # 上锁
    lock.acquire()
    print(threading.current_thread())
    my_list = [3,6,8,1]
    # 判断下标释放越界
    if index >= len(my_list):
        print("下标越界:", index)
        return
    value = my_list[index]
    print(value)
    time.sleep(0.2)
    # 释放锁
    lock.release()

```

#### 10.看门狗:

为了保证程序的稳定持续运行,会使用看门狗来保证一直运行,原理大致是,每隔一段时间给一个变量加一个值(相当于喂狗),只有一直加,就能知道程序活着,如果超时之后,就直接重启程序,保证程序运行

#### 11.避免死锁

程序设计时要尽量避免（银⾏家算法）

添加超时时间等

使用with

with是自动管理资源的函数,当其管理互斥锁时,会自动加锁/解锁

格式:with 互斥锁

​		修改共享资源

```python
import threading
g_number = 0

def update_number1(lock1):
    """子线程函数"""
    global g_number
    for i in range(1000000):
        with lock1:
            g_number += 1

def update_number2(lock1):
    """子线程函数"""
    global g_number
    for i in range(1000000):
        with lock1:
            g_number += 1
def main():
    lock1 = threading.Lock()
    thd1 = threading.Thread(target=update_number1,args=(lock1,))
    thd1.start()
    thd2 = threading.Thread(target=update_number2,args = (lock1,))
    thd2.start()
    thd2.join()
    thd1.join()
    print("获取全局变量的值是%s" % g_number)
if __name__ == '__main__':
    main()

```

#### 12.同步

同步就是协同步调，按预定的先后次序进⾏运⾏,即在线程执行前就已确定了执行的先后顺序,就叫做同步.

实现思路:可以使用多把互斥锁,创建时,只有一把锁不上锁,在调用时,按照顺序,上一个程序完成后,解开下一个程序的锁,就可以保证程序的有序完成.

```python
from threading import Thread,Lock from time	
import	sleep
class	Task1(Thread):				
    def	run(self):								
        while True:										
            if	lock1.acquire():							
                print("------Task	1	-----")				
                sleep(0.5)								
                lock2.release()
class	Task2(Thread):				
    def	run(self):								
        while	True:								
            if	lock2.acquire():							
                print("------Task	2	-----")				
                sleep(0.5)								
                lock3.release()
class	Task3(Thread):				
    def	run(self):								
        while True:										
            if	lock3.acquire():							
                print("------Task	3	-----")				
                sleep(0.5)								
                lock1.release()


```

定义时,先把lock2lock3上锁,就可以使程序在三个程序间交替执行

#### 13.Queue模块

Python的Queue模块中提供了同步的、线程安全的队列类，包括FIFO（fistinfistout先⼊ 先出)队列Queue，LIFO（lastinfistout后⼊先出）队列LifoQueue，和优先级队列 PriorityQueue。

当多个线程配合读写数据时,如果数据的存入速度和数据的读取速度不匹配,比如读取过快时会拿不到数据,产生空闲浪费.存入过快则会导致数据积攒太多,无法处理.

因此可以引入一个间接的容器,来缓存数据.但还要避免多线程处理同一全局变量可能出现的资源竞争问题.

#### **14⽣产者消费者模式**

⽣产者消费者模式是通过⼀个容器来解决⽣产者和消费者的强耦合问题。⽣ 产者和消费者彼此之间不直接通讯，⽽通过阻塞队列来进⾏通讯，所以⽣产 者⽣产完数据之后不⽤等待消费者处理，直接扔给阻塞队列，消费者不找⽣ 产者要数据，⽽是直接从阻塞队列⾥取，阻塞队列就相当于⼀个缓冲区，平 衡了⽣产者和消费者的处理能⼒。
这个阻塞队列就是⽤来给⽣产者和消费者解耦的。纵观⼤多数设计模式，都 会找⼀个第三者出来进⾏解耦，

**耦合性**

耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量,耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差( 降低耦合性，可以提高其独立性)。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分模块的一个准则就是高内聚低耦合。

而在程序中来看,如果程序之间的关系过于复杂,在程序的修改和升级时,会导致修改时很复杂.

如果在最开始的时候程序结构过于复杂,会导致升级时过于复杂,可能会需要重构,即重新写程序.因此要使自己的程序模块化更好,多看看他人写代码的方式.

**注:**

进程中的队列和线程中的队列是不能混着使用的,但其方法和属性是相似的.

队列能存任何类型的数据

实例:设置两个进程写数据,五个线程读数据.

```python
import queue
import threading
import time
q = queue.Queue()

class Cun(threading.Thread):
    def run(self):
        i = 1
        while True:
            if q.qsize() < 100:
                q.put(i)
                # print('存入',i)
                i += 1
            else:
                time.sleep(0.5)


class Read(threading.Thread):
    def run(self):
        while True:
            if q.qsize() > 0:
                num = q.get()
                if num % 100 == 0:
                    print('线程数量为:',len(threading.enumerate()))
                print(num)
            else:
                time.sleep(0.5)

for i in range(2):
    c = Cun()
    c.start()
for j in range(5):
    r = Read()
    r.start()

```



#### 15.全局字典的的使用

使用场景:

当多个线程使用/修改同一个全局变量,但又不想让其对其他的线程进行影响时.还可以认为是想要在函数中定义一个全局变量,并能够在函数外使用.使用全局字典就可以实现这一问题:

实现方法:

在外边定义一个全局字典,将其赋值存在字典中,键名为线程的名字,对字典中的数据修改即可

```python
import threading
num = 1
dict_global = {}
def func1():
    dict_global[threading.current_thread().name] = num + 2
    print('func1.num = ',dict_global[threading.current_thread().name])
def func2():
    dict_global[threading.current_thread().name] = num + 1
    print('func2.num = ',dict_global[threading.current_thread().name])
t1 = threading.Thread(target=func1())
t2 = threading.Thread(target=func2())
t1.start()
t2.start()
#func1.num =  3
#func2.num =  2

```



#### 16.threading.local

在thread模块中,有一个local,可以使用对象名 = thread.local创建一个对象,

在各线程中可以使用对象名.属性来储存当前线程的局部变量,并且能够在后面使用.对应线程使用自己的数据,且不会因为另外的线程对其赋值而改变.

```python
import threading
a = threading.local()
def shuchu():
    num = a.grade
    print(threading.current_thread().name, '成绩为:', num)
def grade_in(grade):
    a.grade = grade
    shuchu()
t1 = threading.Thread(target=grade_in, name ='小米' ,args=(100,))
t2 = threading.Thread(target=grade_in, args=(90,),name='小明')
t1.start()
t2.start()
# 小米 成绩为: 100
# 小明 成绩为: 90

```

#### 17.异步

异步的概念:

与同步相对应,同步时在执行前就设定好执行的顺序,知道什么时候执行什么任务

而异步则不同,异步是不知道程序执行到什么地步会执行其他的任务.当需要执行是,线程就会去执行指定的任务,完成后再回到原来的程序继续执行.

好处:异步不需要等待任务的产生再去工作,而是先完成其他的任务,当等待的任务产生后,执行它,服务完成后再回到原来任务继续执行.

注意:只有pool创建的子进程能够使用callback

```python
定义子进程时使用callback=func

```

func为子进程结束时需要主进程执行的程序,并且如果func()需要参数,且子进程有返回值,返回值会传递给主进程的func

**回调函数和普通函数的区别:**

在python中有回调函数callback,与此方法类似

对普通函数的调用：调用程序发出对普通函数的调用后，程序执行立即转向被调用函数执行，直到被调用函数执行完毕后，再返回调用程序继续执行。从发出调用的程序的角度看，这个过程为“调用-->等待被调用函数执行完毕-->继续执行”

对回调函数调用：调用程序发出对回调函数的调用后，不等函数执行完毕，立即返回并继续执行。这样，调用程序执和被调用函数同时在执行。当被调函数执行完毕后，被调函数会反过来调用某个事先指定函数，以通知调用程序：函数调用结束。这个过程称为回调（Callback），这正是回调函数名称的由来。

**示例**

```python
import multiprocessing
import time
import os
def func1():
    print('我是子进程,pid为:%s,ppid为%s' %(os.getpid(),os.getppid()))
    return '给你了'
def func2(a):
    print(a)
    print(multiprocessing.current_process().name,' pid ',os.getpid())
if __name__ == '__main__':
    p = multiprocessing.Pool(3)
    p.apply_async(func=func1, callback=func2)
    while True:
        print('我是主进程', os.getpid())
        time.sleep(0.5)

```



#### 18.pool创建子进程不加if__ name __ 的问题

 在Windows中创建pool子进程,如果不在if -- name -- 中使用,就会报错

这个问题和操作系统有关系,如果在linux中就不会这样了.



## 网络编程

### 1.网络

⽹络就是⼀种辅助双⽅或者多⽅能够连接在⼀起的⼯具 

使用目的:
就是为了联通多⽅然后进⾏通信⽤的，即把数据从⼀⽅传递给另外⼀⽅,为了让在不同的电脑上运⾏的软件，之间能够互相传递数据，就需要借助⽹络的功能使⽤⽹络能够把多⽅链接在⼀起，然后可以进⾏数据传递 

所谓的⽹络编程就是，让在不同的电脑上的软件能够进⾏数据传递，即 进程之间的通信

#### 1.1TCP/IP协议(族)

​	为了把全世界的所有不同类型的计算机都连接起来，就必须规定⼀套全球通 ⽤的协议，为了实现互联⽹这个⽬标，互联⽹协议簇（Internet	Protocol Suite）就是通⽤协议标准。
因为互联⽹协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP 协议，所以，⼤家把互联⽹的协议简称TCP/IP协议.

#### **1.2协议分层:**

按照作用的层次对协议进行分层

链路层--->网络层--->传输层--->应用层

链路层又可以分为:物理层--->数据链路层

应用层可以分为:会话层--->表示层--->应用层

因此会有七层的分法和四层的.一般写代码按四层,理论上按七层.

### **2.ip**

IP 地址的作用:标识网络中的一台主机设备(系统)



ipv4:格式为点分式,以点隔开的四个八位二进制.

构成为网络号+主机号

ipv4和ipv6

ipv4是现行的ip地址,由四个字节描述,共有接近四十亿地址,以点好间隔

ipv6是将要使用的ip,由八个字节描述,四个四位十六进制数字,以冒号隔开,

​	将要推行的是ipv6+物联网+5g

#### 使用交换机通讯

多台电脑连接交换机流程

发送者将数据/收件人ip以及发件人ip交给交换机,交换机根据ip将数据交给接受者.

接受者也可以根据ip回复

#### **分类**1

公网ip和私网ip

私有ip和公网ip都有固定的区段,用于不同的场合.

公网ip--只有获得公网ip才能够上网,但还可以是多个内网ip公用一个公网ip实现上网

私网ip--不能上外网,只能局域网通讯.



#### 分类2

A类:第一个直接固定

B类:前两个字节固定

C类:只有最后一个字节可变:x.x.x.0-255可用



对于不可变部分相同的ip,称为在同一个网段,不变的部分用于区分设备



同网段的ip不能重复,如果重复会出现两个设备争抢ip的现象,导致设备交替连接



最后一位中,0和255是不可用的,

0表示当前网段,

255则是被广播使用,用于对该局域网所有设备发送消息

D类设备:用于多点广播,即对多个指定的ip发送消息,多用于视频会议



回路测试ip:

127．0．0．1~127．255．255．255⽤于回路测试

常用地为127.0.0.1,代表本机ip地址,用于测试本机的web服务器



#### 查看ip

linux/mac中使用ifconfig---查看网卡信息,主要是看ip信息,其中inet4是ipv4,inet6是ipv6

在win里是ipconfig

在网卡信息中会有一个lo

```shell
lo        Link encap:本地环回  
          inet 地址:127.0.0.1  掩码:255.0.0.0
          inet6 地址: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  跃点数:1
          接收数据包:335 错误:0 丢弃:0 过载:0 帧数:0
          发送数据包:335 错误:0 丢弃:0 过载:0 载波:0
          碰撞:0 发送队列长度:1 
          接收字节:48767 (48.7 KB)  发送字节:48767 (48.7 KB)

```

他的ip只能用于本地测试,不能用于与其他设备通讯



#### ping

用于测试本机和远程主机的网络连通性

格式;

​	ping 域名/ip地址

其实,域名和ip地址在最后发送出去的时候是一个东西,域名通过使用dns域名解析,会转换为ip地址.

如www.baidu.com就是百度的域名,ping这个域名和ping百度的服务器地址效果相同



#### 虚拟机的ip问题

虚拟机的网络设置分为两种模式:NAT模式和桥接模式.

NAT模式中:虚拟机不占用局域网的地址,可以借助外部主机的身份直接访问外网.其相当于使用的是主机内部的网络,外部的设备无法直接访问虚拟机.从外部看,和主机共享一个ip,是主机的一部分.

桥接模式中:虚拟机也会占用局域网的一个地址,并且可以和其他终端进行相互访问.



### 2.1子网掩码

⼦⽹掩码不能单独存在，它必须结合IP地址⼀起使⽤。
⼦⽹掩码只有⼀个作⽤，就是将某个IP地址划分成⽹络地址和主机地址两部 分⼦⽹掩码的设定必须遵循⼀定的规则。

与IP地址相同，⼦⽹掩码的⻓度也是32位，
左边是⽹络位，⽤⼆进制数字“1”表示； 右边是主机位，⽤⼆进制数字“0”表示。

如255.255.255.0就表示的是C类ip,前三个字节表示网络号,最后一个字节表示主机号.

### 3.端口

意义:  标识计算机系统中一个应用程序

​	对于一个ip确定的电脑,通讯时并不知道是和电脑中的哪一个程序通讯,因此,为了确定到底是和谁通讯,需要使用一个各进程唯一的编号.首先想到pid,但是在进程中pid不是固定的,无法固定的与之通讯.

因此引入端口.



**查看端口的使用情况**

在终端输入 netstart -an 在ip后会有各个进程的端口信息.



端口的大小为两个字节,一个65535个端口号,但对其又进行了分类:

分类: 

​	 知名端口  知名服务/程序使用的端口  0-1023

​		HTTP服务 80 	

​		HTTPS服务 443

​		SSH        22	远程登录的安全协议

​		ftp服务	21

HTTP

超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。

HTTPS

是身披SSL外壳的HTTP。HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。



​	 动态端口 1024-65535

​		一些普通程序使用的端口		

如果需要使用知名端口  在 Mac 和 Linux 中需要使用 root 权限  ==sudo 

### 待补充http与https的区别

### 4.套接字

#### 1).含义

socket套接字   台湾网络插座

一套提供**网络通信**的 接口(函数  类)， 底层封装了网络通信细节。

它是网络通信过程中端点的抽象表示，包含进行网络通信必需的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。在python中是可以理解为一个对象,将其实例化之后,可以使用其各种方法和属性

#### 2).常用的套接字

常用的TCP/IP协议的3种套接字类型如下所示。

流式套接字（SOCK_STREAM）：

流式套接字用于提供面向连接、可靠的数据传输服务。该服务将保证数据能够实现无差错、无重复发送，并按顺序接收。流式套接字之所以能够实现可靠的数据服务，原因在于其使用了传输控制协议，即TCP（The Transmission Control Protocol）协议。

数据报套接字（SOCK_DGRAM）：

数据报套接字提供了一种[无连接](https://baike.baidu.com/item/%E6%97%A0%E8%BF%9E%E6%8E%A5)的服务。该服务并不能保证数据传输的可靠性，数据有可能在传输过程中丢失或出现数据重复，且无法保证顺序地接收到数据。数据报套接字使用UDP（User Datagram Protocol）协议进行数据的传输。由于数据报套接字不能保证数据传输的可靠性，对于有可能出现的数据丢失情况，需要在程序中做相应的处理。

原始套接字（SOCK_RAW）：

原始套接字(SOCKET_RAW)允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW





### 5.tcp协议

transmission control protocol  传输控制协议

**1).面向连接**    

​	建立连接 —  通信 — 关闭连接

​	数据传输前会先创建连接,然后再传输数据,传输后会关闭连接

**2).可靠**	

​	**应答机制**   ACK确认字符，在数据通信中，接收站发给发送站的一种传输类[控制字符](https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6/6913704)。表示发来的数据已确认接收无误。

​	**超时重传**   发端设置定时器,超时无应答则会重发

​	**错误校验**  使用一些算法来检验数据的准确性.

​			比如最简单的一种算法为奇偶校验,以1的个数的奇偶作为判断,写在最后一位,奇数写1 偶		数写0 ,当收到数据的一方判断1的个数不符合要求时说明数据出错,就不予理睬,等待重发.

​	**拥塞控制**   发送方会根据实时情况调整发送速度 提高效率.即动态调节速度,因为如果发送的速度过快,接受较慢,会导致数据的丢失,发生丢包.

​	**有序编号**

### 5.1UDP服务器

#### 1)udp通信格式

​        UDP是一种面向无连接的,不可靠的协议.发送数据不需要建立连接,直接发送,不管是否接收(相当于写信)

使用udp套接字通讯:

```pyhton
udp_socket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
udp_socket.sendto('123'.encode(),('192.168.111.1',8080))
```



​	向飞秋发送数据,飞秋是使用udp协议的,使用udp能够将数据发送过去,但是,飞秋还有自己的协议.因此发送的信息不符合飞秋的协议时,飞秋不会有反应.

```pyhton
1:123123123:韩宇:LAPTOP-LEE5SBT9:32:HAHA
```



绑定ip

```python
套接字.bind()
```



接受数据:

```python
套接字.recvfrom(1024)
```

接受的数据为一个元祖的模式,有两个元素,第一个位发送方发送的数据,第二个位发送方的地址.

#### 2)udp广播

​	只有udp会有广播,TCP中没有广播.

当需要给很多人都发数据的时候,只需将一份数据给一个设备,设备将数据给每人发一份.这个设备叫交换机.

需要设置允许发送广播数据:

```python
s.setsockopt(socket.SOL_SOCKET,	socket.SO_BROADCAST,1)
```

设置广播地址:

```python
地址:('<broadcast>',7788)
或者:('192.168.1.255',7788)
```

broadcast表示直接写入广播地址,比直接使用地址好,因为在不同的网段就会有不同的广播地址

**网络通信中的播**

单播	一对一

多播	一对多

广播	一对所有

### 5.2工作模式

单工      只能完成一个操作(接收/发送)

半双工	可以实现发送和接收,但是同一时刻只能干一件事

全双工	可以同时接收和发送,udp和tcp都是全双工























































